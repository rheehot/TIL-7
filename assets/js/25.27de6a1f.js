(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{279:function(t,a,v){"use strict";v.r(a);var _=v(29),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"object-oriendted-programming-oop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#object-oriendted-programming-oop"}},[t._v("#")]),t._v(" Object Oriendted Programming (OOP)")]),t._v(" "),v("h2",{attrs:{id:"객체지향-이전의-프로그래밍과-객체지향-프로그래밍의-패러다임"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-이전의-프로그래밍과-객체지향-프로그래밍의-패러다임"}},[t._v("#")]),t._v(" 객체지향 이전의 프로그래밍과 객체지향 프로그래밍의 패러다임")]),t._v(" "),v("h3",{attrs:{id:"객체지향이전-프로그래밍-패러다임"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#객체지향이전-프로그래밍-패러다임"}},[t._v("#")]),t._v(" 객체지향이전 프로그래밍 패러다임")]),t._v(" "),v("ul",[v("li",[t._v("컴퓨터 중심")]),t._v(" "),v("li",[t._v("컴퓨터가 사고하는대로의 프로그래밍")]),t._v(" "),v("li",[t._v("예시 ?")])]),t._v(" "),v("h3",{attrs:{id:"객체지향-프로그래밍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-프로그래밍"}},[t._v("#")]),t._v(" 객체지향 프로그래밍")]),t._v(" "),v("ul",[v("li",[t._v("인간 중심적 프로그래밍")]),t._v(" "),v("li",[t._v("현실 세계를 프로그래밍으로 옮겨와 프로그래밍 하는 것")]),t._v(" "),v("li",[t._v("추상화\n"),v("ul",[v("li",[t._v("객체 : 현실 세계의 사물들")]),t._v(" "),v("li",[t._v("객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍하는것.")])])])]),t._v(" "),v("h2",{attrs:{id:"객체지향-프로그래밍의-장점과-단점"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-프로그래밍의-장점과-단점"}},[t._v("#")]),t._v(" 객체지향 프로그래밍의 장점과 단점")]),t._v(" "),v("h3",{attrs:{id:"객체지향-프로그래밍의-장점"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-프로그래밍의-장점"}},[t._v("#")]),t._v(" 객체지향 프로그래밍의 장점")]),t._v(" "),v("ul",[v("li",[t._v("재사용성 : 이미 작성한 코드에 대한 재사용성이 높다.\n"),v("ul",[v("li",[t._v("자주사용하는 로직을 라이브러리화 하고. 신뢰성을 확보할 수 있다.")])])]),t._v(" "),v("li",[t._v("버그 에러 감소: 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자의 사소한 실수에도 그 에러를 컴파일단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다.")]),t._v(" "),v("li",[t._v("생산성 : 내부적으로 어떻게 작동하는지 몰라도 개발자는 라이브러리가 제공하는 기능들을 사용할 수 있다.")]),t._v(" "),v("li",[t._v("디버깅, 유지보수 : 객체 단위의 코드 작성")]),t._v(" "),v("li",[t._v("데이터 모델링을 할 때 객체와 매핑하는 것이 수월하여 요구사항을 보다 명확하게 파악하여 프로그래밍을 할 수 있다.")])]),t._v(" "),v("h3",{attrs:{id:"객체지향-프로그래밍의-단점"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-프로그래밍의-단점"}},[t._v("#")]),t._v(" 객체지향 프로그래밍의 단점")]),t._v(" "),v("ul",[v("li",[t._v("객체 간의 정보 교환이 모두 메시지 교환을 통해 일어\n"),v("ul",[v("li",[t._v("실행 시스템에 많은 overhead 가 발생한다.남")]),t._v(" "),v("li",[t._v("하드웨어 발전으로 많이 보완됨")])])]),t._v(" "),v("li",[t._v("객체가 상태를 갖는다.\n"),v("ul",[v("li",[t._v("변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션에서 버그를 발생시킨다.")]),t._v(" "),v("li",[t._v("이러한 이유로 함수형 패러다임이 주목받고 있다.")])])])]),t._v(" "),v("h2",{attrs:{id:"객체지향적-설계-원칙"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#객체지향적-설계-원칙"}},[t._v("#")]),t._v(" 객체지향적 설계 원칙")]),t._v(" "),v("ol",[v("li",[t._v("단일 책임 원칙 SRP(Single Responsibility Principle)\n"),v("ul",[v("li",[t._v("클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.\n...")])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);